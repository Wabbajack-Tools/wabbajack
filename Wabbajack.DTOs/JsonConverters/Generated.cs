// THIS FILE IS AUTOGENERATED DO NOT EDIT BY HAND

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.Extensions.DependencyInjection;
using Wabbajack.DTOs;
using Wabbajack.DTOs.BSA.ArchiveStates;
using Wabbajack.DTOs.BSA.FileStates;
using Wabbajack.DTOs.Directives;
using Wabbajack.DTOs.DownloadStates;
using Wabbajack.DTOs.Texture;
using Wabbajack.Hashing.xxHash64;
using Wabbajack.Paths;

public class Wabbajack_DTOs_DownloadStates_IDownloadStateConverter : JsonConverter<IDownloadState>
{
    public static void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_DeprecatedLoversLabConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_GameFileSourceConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_GoogleDriveConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_HttpConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_LoversLabConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_ManualConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_MediaFireConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_MegaConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_ModDBConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_NexusConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_TESAllianceConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_VectorPlexusConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_WabbajackCDNConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DownloadStates_IDownloadStateConverter>();
    }

    public override IDownloadState Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var cReader = reader;
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        cReader.Read();
        if (cReader.GetString() != "$type")
            throw new JsonException();
        cReader.Read();
        var type = cReader.GetString();
        switch (type)
        {
            case "LoversLabDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<DeprecatedLoversLab>(ref reader, options)!;
            case "GameFileSourceDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<GameFileSource>(ref reader, options)!;
            case "GameFileSource":
                return JsonSerializer.Deserialize<GameFileSource>(ref reader, options)!;
            case "GoogleDriveDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<GoogleDrive>(ref reader, options)!;
            case "GoogleDrive":
                return JsonSerializer.Deserialize<GoogleDrive>(ref reader, options)!;
            case "HttpDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<Http>(ref reader, options)!;
            case "Http":
                return JsonSerializer.Deserialize<Http>(ref reader, options)!;
            case "HttpDownloader":
                return JsonSerializer.Deserialize<Http>(ref reader, options)!;
            case "LoversLabOAuthDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<LoversLab>(ref reader, options)!;
            case "LoversLab":
                return JsonSerializer.Deserialize<LoversLab>(ref reader, options)!;
            case "Manual":
                return JsonSerializer.Deserialize<Manual>(ref reader, options)!;
            case "ManualDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<Manual>(ref reader, options)!;
            case "MediaFireDownloader+State, Wabbajack.Lib":
                return JsonSerializer.Deserialize<MediaFire>(ref reader, options)!;
            case "MediaFire":
                return JsonSerializer.Deserialize<MediaFire>(ref reader, options)!;
            case "MediaFireDownloader":
                return JsonSerializer.Deserialize<MediaFire>(ref reader, options)!;
            case "MegaDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<Mega>(ref reader, options)!;
            case "Mega":
                return JsonSerializer.Deserialize<Mega>(ref reader, options)!;
            case "ModDBDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<ModDB>(ref reader, options)!;
            case "ModDB":
                return JsonSerializer.Deserialize<ModDB>(ref reader, options)!;
            case "ModDBDownloader":
                return JsonSerializer.Deserialize<ModDB>(ref reader, options)!;
            case "NexusDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<Nexus>(ref reader, options)!;
            case "Nexus":
                return JsonSerializer.Deserialize<Nexus>(ref reader, options)!;
            case "TESAllianceDownloader, Wabbajack.Lib":
                return JsonSerializer.Deserialize<TESAlliance>(ref reader, options)!;
            case "TESAlliance":
                return JsonSerializer.Deserialize<TESAlliance>(ref reader, options)!;
            case "VectorPlexusOAuthDownloader+State, Wabbajack.Lib":
                return JsonSerializer.Deserialize<VectorPlexus>(ref reader, options)!;
            case "VectorPlexus":
                return JsonSerializer.Deserialize<VectorPlexus>(ref reader, options)!;
            case "WabbajackCDNDownloader+State, Wabbajack.Lib":
                return JsonSerializer.Deserialize<WabbajackCDN>(ref reader, options)!;
            case "WabbajackCDN":
                return JsonSerializer.Deserialize<WabbajackCDN>(ref reader, options)!;
            default:
                throw new JsonException($"No Type dispatch for {type}");
        }
    }

    public override void Write(Utf8JsonWriter writer, IDownloadState value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case LoversLab v0:
                JsonSerializer.Serialize(writer, v0, options);
                return;
            case VectorPlexus v1:
                JsonSerializer.Serialize(writer, v1, options);
                return;
            case DeprecatedLoversLab v2:
                JsonSerializer.Serialize(writer, v2, options);
                return;
            case GameFileSource v3:
                JsonSerializer.Serialize(writer, v3, options);
                return;
            case GoogleDrive v4:
                JsonSerializer.Serialize(writer, v4, options);
                return;
            case Http v5:
                JsonSerializer.Serialize(writer, v5, options);
                return;
            case Manual v6:
                JsonSerializer.Serialize(writer, v6, options);
                return;
            case MediaFire v7:
                JsonSerializer.Serialize(writer, v7, options);
                return;
            case Mega v8:
                JsonSerializer.Serialize(writer, v8, options);
                return;
            case ModDB v9:
                JsonSerializer.Serialize(writer, v9, options);
                return;
            case Nexus v10:
                JsonSerializer.Serialize(writer, v10, options);
                return;
            case TESAlliance v11:
                JsonSerializer.Serialize(writer, v11, options);
                return;
            case WabbajackCDN v12:
                JsonSerializer.Serialize(writer, v12, options);
                return;
        }
    }
}

public class Wabbajack_DTOs_DownloadStates_DeprecatedLoversLabConverter : JsonConverter<DeprecatedLoversLab>
{
    public override DeprecatedLoversLab Read(ref Utf8JsonReader reader, Type typeToConvert,
        JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                default:
                    reader.Skip();
                    break;
            }
        }

        return new DeprecatedLoversLab();
    }

    public override void Write(Utf8JsonWriter writer, DeprecatedLoversLab value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "LoversLabDownloader, Wabbajack.Lib");
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_GameFileSourceConverter : JsonConverter<GameFileSource>
{
    public override GameFileSource Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Game gameProp = default;
        RelativePath gamefileProp = default;
        string gameversionProp = default;
        Hash hashProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Game":
                    gameProp = JsonSerializer.Deserialize<Game>(ref reader, options);
                    break;
                case "GameFile":
                    gamefileProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "GameVersion":
                    gameversionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new GameFileSource
        {
            Game = gameProp,
            GameFile = gamefileProp,
            GameVersion = gameversionProp,
            Hash = hashProp
        };
    }

    public override void Write(Utf8JsonWriter writer, GameFileSource value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "GameFileSourceDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Game");
        JsonSerializer.Serialize(writer, value.Game, options);
        writer.WritePropertyName("GameFile");
        JsonSerializer.Serialize(writer, value.GameFile, options);
        writer.WritePropertyName("GameVersion");
        JsonSerializer.Serialize(writer, value.GameVersion, options);
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_GoogleDriveConverter : JsonConverter<GoogleDrive>
{
    public override GoogleDrive Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        string idProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Id":
                    idProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new GoogleDrive
        {
            Id = idProp
        };
    }

    public override void Write(Utf8JsonWriter writer, GoogleDrive value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "GoogleDriveDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Id");
        JsonSerializer.Serialize(writer, value.Id, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_HttpConverter : JsonConverter<Http>
{
    public override Http Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        string[] headersProp = default;
        Uri urlProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Headers":
                    headersProp = JsonSerializer.Deserialize<string[]>(ref reader, options);
                    break;
                case "Url":
                    urlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new Http
        {
            Headers = headersProp,
            Url = urlProp
        };
    }

    public override void Write(Utf8JsonWriter writer, Http value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "HttpDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Headers");
        JsonSerializer.Serialize(writer, value.Headers, options);
        writer.WritePropertyName("Url");
        JsonSerializer.Serialize(writer, value.Url, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_LoversLabConverter : JsonConverter<LoversLab>
{
    public override LoversLab Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        string authorProp = default;
        string descriptionProp = default;
        Uri imageurlProp = default;
        string ips4fileProp = default;
        long ips4modProp = default;
        string ips4urlProp = default;
        bool isattachmentProp = default;
        bool isnsfwProp = default;
        string nameProp = default;
        string versionProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Author":
                    authorProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Description":
                    descriptionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "ImageURL":
                    imageurlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                case "IPS4File":
                    ips4fileProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "IPS4Mod":
                    ips4modProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "IPS4Url":
                    ips4urlProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "IsAttachment":
                    isattachmentProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "IsNSFW":
                    isnsfwProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "Name":
                    nameProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Version":
                    versionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new LoversLab
        {
            Author = authorProp,
            Description = descriptionProp,
            ImageURL = imageurlProp,
            IPS4File = ips4fileProp,
            IPS4Mod = ips4modProp,
            IPS4Url = ips4urlProp,
            IsAttachment = isattachmentProp,
            IsNSFW = isnsfwProp,
            Name = nameProp,
            Version = versionProp
        };
    }

    public override void Write(Utf8JsonWriter writer, LoversLab value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "LoversLabOAuthDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Author");
        JsonSerializer.Serialize<string>(writer, value.Author, options);
        writer.WritePropertyName("Description");
        JsonSerializer.Serialize<string>(writer, value.Description, options);
        writer.WritePropertyName("ImageURL");
        JsonSerializer.Serialize<Uri>(writer, value.ImageURL, options);
        writer.WritePropertyName("IPS4File");
        JsonSerializer.Serialize(writer, value.IPS4File, options);
        writer.WritePropertyName("IPS4Mod");
        JsonSerializer.Serialize(writer, value.IPS4Mod, options);
        writer.WritePropertyName("IPS4Url");
        JsonSerializer.Serialize(writer, value.IPS4Url, options);
        writer.WritePropertyName("IsAttachment");
        JsonSerializer.Serialize(writer, value.IsAttachment, options);
        writer.WritePropertyName("IsNSFW");
        JsonSerializer.Serialize(writer, value.IsNSFW, options);
        writer.WritePropertyName("Name");
        JsonSerializer.Serialize<string>(writer, value.Name, options);
        writer.WritePropertyName("Version");
        JsonSerializer.Serialize<string>(writer, value.Version, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_ManualConverter : JsonConverter<Manual>
{
    public override Manual Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Uri urlProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Url":
                    urlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new Manual
        {
            Url = urlProp
        };
    }

    public override void Write(Utf8JsonWriter writer, Manual value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "Manual");
        writer.WritePropertyName("Url");
        JsonSerializer.Serialize(writer, value.Url, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_MediaFireConverter : JsonConverter<MediaFire>
{
    public override MediaFire Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Uri urlProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Url":
                    urlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new MediaFire
        {
            Url = urlProp
        };
    }

    public override void Write(Utf8JsonWriter writer, MediaFire value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "MediaFireDownloader+State, Wabbajack.Lib");
        writer.WritePropertyName("Url");
        JsonSerializer.Serialize(writer, value.Url, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_MegaConverter : JsonConverter<Mega>
{
    public override Mega Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Uri urlProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Url":
                    urlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new Mega
        {
            Url = urlProp
        };
    }

    public override void Write(Utf8JsonWriter writer, Mega value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "MegaDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Url");
        JsonSerializer.Serialize(writer, value.Url, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_ModDBConverter : JsonConverter<ModDB>
{
    public override ModDB Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Uri urlProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Url":
                    urlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new ModDB
        {
            Url = urlProp
        };
    }

    public override void Write(Utf8JsonWriter writer, ModDB value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "ModDBDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Url");
        JsonSerializer.Serialize(writer, value.Url, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_NexusConverter : JsonConverter<Nexus>
{
    public override Nexus Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        string authorProp = default;
        string descriptionProp = default;
        long fileidProp = default;
        Game gamenameProp = default;
        Uri imageurlProp = default;
        bool isnsfwProp = default;
        long modidProp = default;
        string nameProp = default;
        string versionProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Author":
                    authorProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Description":
                    descriptionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "FileID":
                    fileidProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "GameName":
                    gamenameProp = JsonSerializer.Deserialize<Game>(ref reader, options);
                    break;
                case "ImageURL":
                    imageurlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                case "IsNSFW":
                    isnsfwProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "ModID":
                    modidProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "Name":
                    nameProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Version":
                    versionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new Nexus
        {
            Author = authorProp,
            Description = descriptionProp,
            FileID = fileidProp,
            Game = gamenameProp,
            ImageURL = imageurlProp,
            IsNSFW = isnsfwProp,
            ModID = modidProp,
            Name = nameProp,
            Version = versionProp
        };
    }

    public override void Write(Utf8JsonWriter writer, Nexus value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "NexusDownloader, Wabbajack.Lib");
        writer.WritePropertyName("Author");
        JsonSerializer.Serialize<string>(writer, value.Author, options);
        writer.WritePropertyName("Description");
        JsonSerializer.Serialize<string>(writer, value.Description, options);
        writer.WritePropertyName("FileID");
        JsonSerializer.Serialize(writer, value.FileID, options);
        writer.WritePropertyName("GameName");
        JsonSerializer.Serialize(writer, value.Game, options);
        writer.WritePropertyName("ImageURL");
        JsonSerializer.Serialize<Uri>(writer, value.ImageURL, options);
        writer.WritePropertyName("IsNSFW");
        JsonSerializer.Serialize(writer, value.IsNSFW, options);
        writer.WritePropertyName("ModID");
        JsonSerializer.Serialize(writer, value.ModID, options);
        writer.WritePropertyName("Name");
        JsonSerializer.Serialize<string>(writer, value.Name, options);
        writer.WritePropertyName("Version");
        JsonSerializer.Serialize<string>(writer, value.Version, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_TESAllianceConverter : JsonConverter<TESAlliance>
{
    public override TESAlliance Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        string fileidProp = default;
        string filenameProp = default;
        Uri fullurlProp = default;
        bool isattachmentProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "FileID":
                    fileidProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "FileName":
                    filenameProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "FullURL":
                    fullurlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                case "IsAttachment":
                    isattachmentProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new TESAlliance
        {
            FileID = fileidProp,
            FileName = filenameProp,
            FullURL = fullurlProp,
            IsAttachment = isattachmentProp
        };
    }

    public override void Write(Utf8JsonWriter writer, TESAlliance value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "TESAllianceDownloader, Wabbajack.Lib");
        writer.WritePropertyName("FileID");
        JsonSerializer.Serialize(writer, value.FileID, options);
        writer.WritePropertyName("FileName");
        JsonSerializer.Serialize(writer, value.FileName, options);
        writer.WritePropertyName("FullURL");
        JsonSerializer.Serialize(writer, value.FullURL, options);
        writer.WritePropertyName("IsAttachment");
        JsonSerializer.Serialize(writer, value.IsAttachment, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_VectorPlexusConverter : JsonConverter<VectorPlexus>
{
    public override VectorPlexus Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        string authorProp = default;
        string descriptionProp = default;
        Uri imageurlProp = default;
        string ips4fileProp = default;
        long ips4modProp = default;
        string ips4urlProp = default;
        bool isattachmentProp = default;
        bool isnsfwProp = default;
        string nameProp = default;
        string versionProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Author":
                    authorProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Description":
                    descriptionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "ImageURL":
                    imageurlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                case "IPS4File":
                    ips4fileProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "IPS4Mod":
                    ips4modProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "IPS4Url":
                    ips4urlProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "IsAttachment":
                    isattachmentProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "IsNSFW":
                    isnsfwProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "Name":
                    nameProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Version":
                    versionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new VectorPlexus
        {
            Author = authorProp,
            Description = descriptionProp,
            ImageURL = imageurlProp,
            IPS4File = ips4fileProp,
            IPS4Mod = ips4modProp,
            IPS4Url = ips4urlProp,
            IsAttachment = isattachmentProp,
            IsNSFW = isnsfwProp,
            Name = nameProp,
            Version = versionProp
        };
    }

    public override void Write(Utf8JsonWriter writer, VectorPlexus value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "VectorPlexusOAuthDownloader+State, Wabbajack.Lib");
        writer.WritePropertyName("Author");
        JsonSerializer.Serialize<string>(writer, value.Author, options);
        writer.WritePropertyName("Description");
        JsonSerializer.Serialize<string>(writer, value.Description, options);
        writer.WritePropertyName("ImageURL");
        JsonSerializer.Serialize<Uri>(writer, value.ImageURL, options);
        writer.WritePropertyName("IPS4File");
        JsonSerializer.Serialize(writer, value.IPS4File, options);
        writer.WritePropertyName("IPS4Mod");
        JsonSerializer.Serialize(writer, value.IPS4Mod, options);
        writer.WritePropertyName("IPS4Url");
        JsonSerializer.Serialize(writer, value.IPS4Url, options);
        writer.WritePropertyName("IsAttachment");
        JsonSerializer.Serialize(writer, value.IsAttachment, options);
        writer.WritePropertyName("IsNSFW");
        JsonSerializer.Serialize(writer, value.IsNSFW, options);
        writer.WritePropertyName("Name");
        JsonSerializer.Serialize<string>(writer, value.Name, options);
        writer.WritePropertyName("Version");
        JsonSerializer.Serialize<string>(writer, value.Version, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DownloadStates_WabbajackCDNConverter : JsonConverter<WabbajackCDN>
{
    public override WabbajackCDN Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Uri urlProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Url":
                    urlProp = JsonSerializer.Deserialize<Uri>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new WabbajackCDN
        {
            Url = urlProp
        };
    }

    public override void Write(Utf8JsonWriter writer, WabbajackCDN value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "WabbajackCDNDownloader+State, Wabbajack.Lib");
        writer.WritePropertyName("Url");
        JsonSerializer.Serialize(writer, value.Url, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_ArchiveStates_IArchiveConverter : JsonConverter<IArchive>
{
    public static void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_ArchiveStates_BA2StateConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_ArchiveStates_BSAStateConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_ArchiveStates_TES3StateConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_ArchiveStates_IArchiveConverter>();
    }

    public override IArchive Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var cReader = reader;
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        cReader.Read();
        if (cReader.GetString() != "$type")
            throw new JsonException();
        cReader.Read();
        var type = cReader.GetString();
        switch (type)
        {
            case "BA2State, Compression.BSA":
                return JsonSerializer.Deserialize<BA2State>(ref reader, options)!;
            case "BA2State":
                return JsonSerializer.Deserialize<BA2State>(ref reader, options)!;
            case "BSAState, Compression.BSA":
                return JsonSerializer.Deserialize<BSAState>(ref reader, options)!;
            case "BSAState":
                return JsonSerializer.Deserialize<BSAState>(ref reader, options)!;
            case "TES3State":
                return JsonSerializer.Deserialize<TES3State>(ref reader, options)!;
            case "TES3State, Compression.BSA":
                return JsonSerializer.Deserialize<TES3State>(ref reader, options)!;
            default:
                throw new JsonException($"No Type dispatch for {type}");
        }
    }

    public override void Write(Utf8JsonWriter writer, IArchive value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case BA2State v0:
                JsonSerializer.Serialize(writer, v0, options);
                return;
            case BSAState v1:
                JsonSerializer.Serialize(writer, v1, options);
                return;
            case TES3State v2:
                JsonSerializer.Serialize(writer, v2, options);
                return;
        }
    }
}

public class Wabbajack_DTOs_BSA_ArchiveStates_BA2StateConverter : JsonConverter<BA2State>
{
    public override BA2State Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        bool hasnametableProp = default;
        string headermagicProp = default;
        BA2EntryType typeProp = default;
        uint versionProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "HasNameTable":
                    hasnametableProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "HeaderMagic":
                    headermagicProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Type":
                    typeProp = JsonSerializer.Deserialize<BA2EntryType>(ref reader, options);
                    break;
                case "Version":
                    versionProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new BA2State
        {
            HasNameTable = hasnametableProp,
            HeaderMagic = headermagicProp,
            Type = typeProp,
            Version = versionProp
        };
    }

    public override void Write(Utf8JsonWriter writer, BA2State value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "BA2State, Compression.BSA");
        writer.WritePropertyName("HasNameTable");
        JsonSerializer.Serialize(writer, value.HasNameTable, options);
        writer.WritePropertyName("HeaderMagic");
        JsonSerializer.Serialize(writer, value.HeaderMagic, options);
        writer.WritePropertyName("Type");
        JsonSerializer.Serialize(writer, value.Type, options);
        writer.WritePropertyName("Version");
        JsonSerializer.Serialize(writer, value.Version, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_ArchiveStates_BSAStateConverter : JsonConverter<BSAState>
{
    public override BSAState Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        uint archiveflagsProp = default;
        uint fileflagsProp = default;
        string magicProp = default;
        uint versionProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "ArchiveFlags":
                    archiveflagsProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "FileFlags":
                    fileflagsProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Magic":
                    magicProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Version":
                    versionProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new BSAState
        {
            ArchiveFlags = archiveflagsProp,
            FileFlags = fileflagsProp,
            Magic = magicProp,
            Version = versionProp
        };
    }

    public override void Write(Utf8JsonWriter writer, BSAState value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "BSAState, Compression.BSA");
        writer.WritePropertyName("ArchiveFlags");
        JsonSerializer.Serialize(writer, value.ArchiveFlags, options);
        writer.WritePropertyName("FileFlags");
        JsonSerializer.Serialize(writer, value.FileFlags, options);
        writer.WritePropertyName("Magic");
        JsonSerializer.Serialize(writer, value.Magic, options);
        writer.WritePropertyName("Version");
        JsonSerializer.Serialize(writer, value.Version, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_ArchiveStates_TES3StateConverter : JsonConverter<TES3State>
{
    public override TES3State Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        long dataoffsetProp = default;
        uint filecountProp = default;
        uint hashoffsetProp = default;
        uint versionnumberProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "DataOffset":
                    dataoffsetProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "FileCount":
                    filecountProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "HashOffset":
                    hashoffsetProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "VersionNumber":
                    versionnumberProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new TES3State
        {
            DataOffset = dataoffsetProp,
            FileCount = filecountProp,
            HashOffset = hashoffsetProp,
            VersionNumber = versionnumberProp
        };
    }

    public override void Write(Utf8JsonWriter writer, TES3State value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "TES3State");
        writer.WritePropertyName("DataOffset");
        JsonSerializer.Serialize(writer, value.DataOffset, options);
        writer.WritePropertyName("FileCount");
        JsonSerializer.Serialize(writer, value.FileCount, options);
        writer.WritePropertyName("HashOffset");
        JsonSerializer.Serialize(writer, value.HashOffset, options);
        writer.WritePropertyName("VersionNumber");
        JsonSerializer.Serialize(writer, value.VersionNumber, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_DirectiveConverter : JsonConverter<Directive>
{
    public static void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_ArchiveMetaConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_CreateBSAConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_FromArchiveConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_IgnoredDirectlyConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_InlineFileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_MergedPatchConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_NoMatchConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_PatchedFromArchiveConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_PropertyFileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_RemappedInlineFileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_Directives_TransformedTextureConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_DirectiveConverter>();
    }

    public override Directive Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var cReader = reader;
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        cReader.Read();
        if (cReader.GetString() != "$type")
            throw new JsonException();
        cReader.Read();
        var type = cReader.GetString();
        switch (type)
        {
            case "ArchiveMeta":
                return JsonSerializer.Deserialize<ArchiveMeta>(ref reader, options)!;
            case "ArchiveMeta, Wabbajack.Lib":
                return JsonSerializer.Deserialize<ArchiveMeta>(ref reader, options)!;
            case "CreateBSA":
                return JsonSerializer.Deserialize<CreateBSA>(ref reader, options)!;
            case "CreateBSA, Wabbajack.Lib":
                return JsonSerializer.Deserialize<CreateBSA>(ref reader, options)!;
            case "FromArchive":
                return JsonSerializer.Deserialize<FromArchive>(ref reader, options)!;
            case "FromArchive, Wabbajack.Lib":
                return JsonSerializer.Deserialize<FromArchive>(ref reader, options)!;
            case "IgnoredDirectly":
                return JsonSerializer.Deserialize<IgnoredDirectly>(ref reader, options)!;
            case "InlineFile":
                return JsonSerializer.Deserialize<InlineFile>(ref reader, options)!;
            case "InlineFile, Wabbajack.Lib":
                return JsonSerializer.Deserialize<InlineFile>(ref reader, options)!;
            case "MergedPatch, Wabbajack.Lib":
                return JsonSerializer.Deserialize<MergedPatch>(ref reader, options)!;
            case "MergedPatch":
                return JsonSerializer.Deserialize<MergedPatch>(ref reader, options)!;
            case "NoMatch":
                return JsonSerializer.Deserialize<NoMatch>(ref reader, options)!;
            case "PatchedFromArchive":
                return JsonSerializer.Deserialize<PatchedFromArchive>(ref reader, options)!;
            case "PatchedFromArchive, Wabbajack.Lib":
                return JsonSerializer.Deserialize<PatchedFromArchive>(ref reader, options)!;
            case "PropertyFile":
                return JsonSerializer.Deserialize<PropertyFile>(ref reader, options)!;
            case "PropertyFile, Wabbajack.Lib":
                return JsonSerializer.Deserialize<PropertyFile>(ref reader, options)!;
            case "RemappedInlineFile":
                return JsonSerializer.Deserialize<RemappedInlineFile>(ref reader, options)!;
            case "RemappedInlineFile, Wabbajack.Lib":
                return JsonSerializer.Deserialize<RemappedInlineFile>(ref reader, options)!;
            case "TransformedTexture":
                return JsonSerializer.Deserialize<TransformedTexture>(ref reader, options)!;
            case "TransformedTexture, Wabbajack.Lib":
                return JsonSerializer.Deserialize<TransformedTexture>(ref reader, options)!;
            default:
                throw new JsonException($"No Type dispatch for {type}");
        }
    }

    public override void Write(Utf8JsonWriter writer, Directive value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case NoMatch v0:
                JsonSerializer.Serialize(writer, v0, options);
                return;
            case PatchedFromArchive v1:
                JsonSerializer.Serialize(writer, v1, options);
                return;
            case PropertyFile v2:
                JsonSerializer.Serialize(writer, v2, options);
                return;
            case RemappedInlineFile v3:
                JsonSerializer.Serialize(writer, v3, options);
                return;
            case TransformedTexture v4:
                JsonSerializer.Serialize(writer, v4, options);
                return;
            case ArchiveMeta v5:
                JsonSerializer.Serialize(writer, v5, options);
                return;
            case CreateBSA v6:
                JsonSerializer.Serialize(writer, v6, options);
                return;
            case FromArchive v7:
                JsonSerializer.Serialize(writer, v7, options);
                return;
            case IgnoredDirectly v8:
                JsonSerializer.Serialize(writer, v8, options);
                return;
            case InlineFile v9:
                JsonSerializer.Serialize(writer, v9, options);
                return;
            case MergedPatch v10:
                JsonSerializer.Serialize(writer, v10, options);
                return;
        }
    }
}

public class Wabbajack_DTOs_Directives_ArchiveMetaConverter : JsonConverter<ArchiveMeta>
{
    public override ArchiveMeta Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath sourcedataidProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "SourceDataID":
                    sourcedataidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new ArchiveMeta
        {
            Hash = hashProp,
            Size = sizeProp,
            SourceDataID = sourcedataidProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, ArchiveMeta value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "ArchiveMeta");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("SourceDataID");
        JsonSerializer.Serialize(writer, value.SourceDataID, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_CreateBSAConverter : JsonConverter<CreateBSA>
{
    public override CreateBSA Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        AFile[] filestatesProp = default;
        Hash hashProp = default;
        long sizeProp = default;
        IArchive stateProp = default;
        RelativePath tempidProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "FileStates":
                    filestatesProp = JsonSerializer.Deserialize<AFile[]>(ref reader, options);
                    break;
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "State":
                    stateProp = JsonSerializer.Deserialize<IArchive>(ref reader, options);
                    break;
                case "TempID":
                    tempidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new CreateBSA
        {
            FileStates = filestatesProp,
            Hash = hashProp,
            Size = sizeProp,
            State = stateProp,
            TempID = tempidProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, CreateBSA value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "CreateBSA");
        writer.WritePropertyName("FileStates");
        JsonSerializer.Serialize(writer, value.FileStates, options);
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("State");
        JsonSerializer.Serialize(writer, value.State, options);
        writer.WritePropertyName("TempID");
        JsonSerializer.Serialize(writer, value.TempID, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_FromArchiveConverter : JsonConverter<FromArchive>
{
    public override FromArchive Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        HashRelativePath archivehashpathProp = default;
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "ArchiveHashPath":
                    archivehashpathProp = JsonSerializer.Deserialize<HashRelativePath>(ref reader, options);
                    break;
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new FromArchive
        {
            ArchiveHashPath = archivehashpathProp,
            Hash = hashProp,
            Size = sizeProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, FromArchive value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "FromArchive");
        writer.WritePropertyName("ArchiveHashPath");
        JsonSerializer.Serialize(writer, value.ArchiveHashPath, options);
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_IgnoredDirectlyConverter : JsonConverter<IgnoredDirectly>
{
    public override IgnoredDirectly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new IgnoredDirectly
        {
            Hash = hashProp,
            Size = sizeProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, IgnoredDirectly value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "IgnoredDirectly");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_InlineFileConverter : JsonConverter<InlineFile>
{
    public override InlineFile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath sourcedataidProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "SourceDataID":
                    sourcedataidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new InlineFile
        {
            Hash = hashProp,
            Size = sizeProp,
            SourceDataID = sourcedataidProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, InlineFile value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "InlineFile");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("SourceDataID");
        JsonSerializer.Serialize(writer, value.SourceDataID, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_MergedPatchConverter : JsonConverter<MergedPatch>
{
    public override MergedPatch Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        RelativePath patchidProp = default;
        long sizeProp = default;
        SourcePatch[] sourcesProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "PatchID":
                    patchidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "Sources":
                    sourcesProp = JsonSerializer.Deserialize<SourcePatch[]>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new MergedPatch
        {
            Hash = hashProp,
            PatchID = patchidProp,
            Size = sizeProp,
            Sources = sourcesProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, MergedPatch value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "MergedPatch, Wabbajack.Lib");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("PatchID");
        JsonSerializer.Serialize(writer, value.PatchID, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("Sources");
        JsonSerializer.Serialize(writer, value.Sources, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_NoMatchConverter : JsonConverter<NoMatch>
{
    public override NoMatch Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new NoMatch
        {
            Hash = hashProp,
            Size = sizeProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, NoMatch value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "NoMatch");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_PatchedFromArchiveConverter : JsonConverter<PatchedFromArchive>
{
    public override PatchedFromArchive Read(ref Utf8JsonReader reader, Type typeToConvert,
        JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        HashRelativePath archivehashpathProp = default;
        Hash fromhashProp = default;
        Hash hashProp = default;
        RelativePath patchidProp = default;
        long sizeProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "ArchiveHashPath":
                    archivehashpathProp = JsonSerializer.Deserialize<HashRelativePath>(ref reader, options);
                    break;
                case "FromHash":
                    fromhashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "PatchID":
                    patchidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new PatchedFromArchive
        {
            ArchiveHashPath = archivehashpathProp,
            FromHash = fromhashProp,
            Hash = hashProp,
            PatchID = patchidProp,
            Size = sizeProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, PatchedFromArchive value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "PatchedFromArchive");
        writer.WritePropertyName("ArchiveHashPath");
        JsonSerializer.Serialize(writer, value.ArchiveHashPath, options);
        writer.WritePropertyName("FromHash");
        JsonSerializer.Serialize(writer, value.FromHash, options);
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("PatchID");
        JsonSerializer.Serialize(writer, value.PatchID, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_PropertyFileConverter : JsonConverter<PropertyFile>
{
    public override PropertyFile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath sourcedataidProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "SourceDataID":
                    sourcedataidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new PropertyFile
        {
            Hash = hashProp,
            Size = sizeProp,
            SourceDataID = sourcedataidProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, PropertyFile value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "PropertyFile");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("SourceDataID");
        JsonSerializer.Serialize(writer, value.SourceDataID, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_RemappedInlineFileConverter : JsonConverter<RemappedInlineFile>
{
    public override RemappedInlineFile Read(ref Utf8JsonReader reader, Type typeToConvert,
        JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        Hash hashProp = default;
        long sizeProp = default;
        RelativePath sourcedataidProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "SourceDataID":
                    sourcedataidProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new RemappedInlineFile
        {
            Hash = hashProp,
            Size = sizeProp,
            SourceDataID = sourcedataidProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, RemappedInlineFile value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "RemappedInlineFile");
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("SourceDataID");
        JsonSerializer.Serialize(writer, value.SourceDataID, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_Directives_TransformedTextureConverter : JsonConverter<TransformedTexture>
{
    public override TransformedTexture Read(ref Utf8JsonReader reader, Type typeToConvert,
        JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        HashRelativePath archivehashpathProp = default;
        Hash hashProp = default;
        ImageState imagestateProp = default;
        long sizeProp = default;
        RelativePath toProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "ArchiveHashPath":
                    archivehashpathProp = JsonSerializer.Deserialize<HashRelativePath>(ref reader, options);
                    break;
                case "Hash":
                    hashProp = JsonSerializer.Deserialize<Hash>(ref reader, options);
                    break;
                case "ImageState":
                    imagestateProp = JsonSerializer.Deserialize<ImageState>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<long>(ref reader, options);
                    break;
                case "To":
                    toProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new TransformedTexture
        {
            ArchiveHashPath = archivehashpathProp,
            Hash = hashProp,
            ImageState = imagestateProp,
            Size = sizeProp,
            To = toProp
        };
    }

    public override void Write(Utf8JsonWriter writer, TransformedTexture value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "TransformedTexture");
        writer.WritePropertyName("ArchiveHashPath");
        JsonSerializer.Serialize(writer, value.ArchiveHashPath, options);
        writer.WritePropertyName("Hash");
        JsonSerializer.Serialize(writer, value.Hash, options);
        writer.WritePropertyName("ImageState");
        JsonSerializer.Serialize(writer, value.ImageState, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WritePropertyName("To");
        JsonSerializer.Serialize(writer, value.To, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_FileStates_AFileConverter : JsonConverter<AFile>
{
    public static void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_FileStates_BA2DX10FileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_FileStates_BA2FileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_FileStates_BSAFileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_FileStates_TES3FileConverter>();
        services.AddSingleton<JsonConverter, Wabbajack_DTOs_BSA_FileStates_AFileConverter>();
    }

    public override AFile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var cReader = reader;
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        cReader.Read();
        if (cReader.GetString() != "$type")
            throw new JsonException();
        cReader.Read();
        var type = cReader.GetString();
        switch (type)
        {
            case "BA2DX10Entry":
                return JsonSerializer.Deserialize<BA2DX10File>(ref reader, options)!;
            case "BA2DX10Entry, Compression.BSA":
                return JsonSerializer.Deserialize<BA2DX10File>(ref reader, options)!;
            case "BA2File":
                return JsonSerializer.Deserialize<BA2File>(ref reader, options)!;
            case "BA2FileEntryState, Compression.BSA":
                return JsonSerializer.Deserialize<BA2File>(ref reader, options)!;
            case "BSAFileState, Compression.BSA":
                return JsonSerializer.Deserialize<BSAFile>(ref reader, options)!;
            case "BSAFile":
                return JsonSerializer.Deserialize<BSAFile>(ref reader, options)!;
            case "TES3File":
                return JsonSerializer.Deserialize<TES3File>(ref reader, options)!;
            default:
                throw new JsonException($"No Type dispatch for {type}");
        }
    }

    public override void Write(Utf8JsonWriter writer, AFile value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case BA2DX10File v0:
                JsonSerializer.Serialize(writer, v0, options);
                return;
            case BA2File v1:
                JsonSerializer.Serialize(writer, v1, options);
                return;
            case BSAFile v2:
                JsonSerializer.Serialize(writer, v2, options);
                return;
            case TES3File v3:
                JsonSerializer.Serialize(writer, v3, options);
                return;
        }
    }
}

public class Wabbajack_DTOs_BSA_FileStates_BA2DX10FileConverter : JsonConverter<BA2DX10File>
{
    public override BA2DX10File Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        ushort chunkhdrlenProp = default;
        BA2Chunk[] chunksProp = default;
        uint dirhashProp = default;
        string extensionProp = default;
        ushort heightProp = default;
        int indexProp = default;
        uint namehashProp = default;
        byte nummipsProp = default;
        RelativePath pathProp = default;
        byte pixelformatProp = default;
        ushort unk16Prop = default;
        byte unk8Prop = default;
        ushort widthProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "ChunkHdrLen":
                    chunkhdrlenProp = JsonSerializer.Deserialize<ushort>(ref reader, options);
                    break;
                case "Chunks":
                    chunksProp = JsonSerializer.Deserialize<BA2Chunk[]>(ref reader, options);
                    break;
                case "DirHash":
                    dirhashProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Extension":
                    extensionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Height":
                    heightProp = JsonSerializer.Deserialize<ushort>(ref reader, options);
                    break;
                case "Index":
                    indexProp = JsonSerializer.Deserialize<int>(ref reader, options);
                    break;
                case "NameHash":
                    namehashProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "NumMips":
                    nummipsProp = JsonSerializer.Deserialize<byte>(ref reader, options);
                    break;
                case "Path":
                    pathProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "PixelFormat":
                    pixelformatProp = JsonSerializer.Deserialize<byte>(ref reader, options);
                    break;
                case "Unk16":
                    unk16Prop = JsonSerializer.Deserialize<ushort>(ref reader, options);
                    break;
                case "Unk8":
                    unk8Prop = JsonSerializer.Deserialize<byte>(ref reader, options);
                    break;
                case "Width":
                    widthProp = JsonSerializer.Deserialize<ushort>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new BA2DX10File
        {
            ChunkHdrLen = chunkhdrlenProp,
            Chunks = chunksProp,
            DirHash = dirhashProp,
            Extension = extensionProp,
            Height = heightProp,
            Index = indexProp,
            NameHash = namehashProp,
            NumMips = nummipsProp,
            Path = pathProp,
            PixelFormat = pixelformatProp,
            Unk16 = unk16Prop,
            Unk8 = unk8Prop,
            Width = widthProp
        };
    }

    public override void Write(Utf8JsonWriter writer, BA2DX10File value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "BA2DX10Entry");
        writer.WritePropertyName("ChunkHdrLen");
        JsonSerializer.Serialize(writer, value.ChunkHdrLen, options);
        writer.WritePropertyName("Chunks");
        JsonSerializer.Serialize(writer, value.Chunks, options);
        writer.WritePropertyName("DirHash");
        JsonSerializer.Serialize(writer, value.DirHash, options);
        writer.WritePropertyName("Extension");
        JsonSerializer.Serialize(writer, value.Extension, options);
        writer.WritePropertyName("Height");
        JsonSerializer.Serialize(writer, value.Height, options);
        writer.WritePropertyName("Index");
        JsonSerializer.Serialize(writer, value.Index, options);
        writer.WritePropertyName("NameHash");
        JsonSerializer.Serialize(writer, value.NameHash, options);
        writer.WritePropertyName("NumMips");
        JsonSerializer.Serialize(writer, value.NumMips, options);
        writer.WritePropertyName("Path");
        JsonSerializer.Serialize(writer, value.Path, options);
        writer.WritePropertyName("PixelFormat");
        JsonSerializer.Serialize(writer, value.PixelFormat, options);
        writer.WritePropertyName("Unk16");
        JsonSerializer.Serialize(writer, value.Unk16, options);
        writer.WritePropertyName("Unk8");
        JsonSerializer.Serialize(writer, value.Unk8, options);
        writer.WritePropertyName("Width");
        JsonSerializer.Serialize(writer, value.Width, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_FileStates_BA2FileConverter : JsonConverter<BA2File>
{
    public override BA2File Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        uint alignProp = default;
        bool compressedProp = default;
        uint dirhashProp = default;
        string extensionProp = default;
        uint flagsProp = default;
        int indexProp = default;
        uint namehashProp = default;
        RelativePath pathProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Align":
                    alignProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Compressed":
                    compressedProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "DirHash":
                    dirhashProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Extension":
                    extensionProp = JsonSerializer.Deserialize<string>(ref reader, options);
                    break;
                case "Flags":
                    flagsProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Index":
                    indexProp = JsonSerializer.Deserialize<int>(ref reader, options);
                    break;
                case "NameHash":
                    namehashProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Path":
                    pathProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new BA2File
        {
            Align = alignProp,
            Compressed = compressedProp,
            DirHash = dirhashProp,
            Extension = extensionProp,
            Flags = flagsProp,
            Index = indexProp,
            NameHash = namehashProp,
            Path = pathProp
        };
    }

    public override void Write(Utf8JsonWriter writer, BA2File value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "BA2File");
        writer.WritePropertyName("Align");
        JsonSerializer.Serialize(writer, value.Align, options);
        writer.WritePropertyName("Compressed");
        JsonSerializer.Serialize(writer, value.Compressed, options);
        writer.WritePropertyName("DirHash");
        JsonSerializer.Serialize(writer, value.DirHash, options);
        writer.WritePropertyName("Extension");
        JsonSerializer.Serialize(writer, value.Extension, options);
        writer.WritePropertyName("Flags");
        JsonSerializer.Serialize(writer, value.Flags, options);
        writer.WritePropertyName("Index");
        JsonSerializer.Serialize(writer, value.Index, options);
        writer.WritePropertyName("NameHash");
        JsonSerializer.Serialize(writer, value.NameHash, options);
        writer.WritePropertyName("Path");
        JsonSerializer.Serialize(writer, value.Path, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_FileStates_BSAFileConverter : JsonConverter<BSAFile>
{
    public override BSAFile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        bool flipcompressionProp = default;
        int indexProp = default;
        RelativePath pathProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "FlipCompression":
                    flipcompressionProp = JsonSerializer.Deserialize<bool>(ref reader, options);
                    break;
                case "Index":
                    indexProp = JsonSerializer.Deserialize<int>(ref reader, options);
                    break;
                case "Path":
                    pathProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new BSAFile
        {
            FlipCompression = flipcompressionProp,
            Index = indexProp,
            Path = pathProp
        };
    }

    public override void Write(Utf8JsonWriter writer, BSAFile value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "BSAFileState, Compression.BSA");
        writer.WritePropertyName("FlipCompression");
        JsonSerializer.Serialize(writer, value.FlipCompression, options);
        writer.WritePropertyName("Index");
        JsonSerializer.Serialize(writer, value.Index, options);
        writer.WritePropertyName("Path");
        JsonSerializer.Serialize(writer, value.Path, options);
        writer.WriteEndObject();
    }
}

public class Wabbajack_DTOs_BSA_FileStates_TES3FileConverter : JsonConverter<TES3File>
{
    public override TES3File Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
            throw new JsonException();
        uint hash1Prop = default;
        uint hash2Prop = default;
        int indexProp = default;
        uint nameoffsetProp = default;
        uint offsetProp = default;
        RelativePath pathProp = default;
        uint sizeProp = default;
        while (true)
        {
            reader.Read();
            if (reader.TokenType == JsonTokenType.EndObject)
            {
                reader.Read();
                break;
            }

            var prop = reader.GetString();
            reader.Read();
            switch (prop)
            {
                case "Hash1":
                    hash1Prop = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Hash2":
                    hash2Prop = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Index":
                    indexProp = JsonSerializer.Deserialize<int>(ref reader, options);
                    break;
                case "NameOffset":
                    nameoffsetProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Offset":
                    offsetProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                case "Path":
                    pathProp = JsonSerializer.Deserialize<RelativePath>(ref reader, options);
                    break;
                case "Size":
                    sizeProp = JsonSerializer.Deserialize<uint>(ref reader, options);
                    break;
                default:
                    reader.Skip();
                    break;
            }
        }

        return new TES3File
        {
            Hash1 = hash1Prop,
            Hash2 = hash2Prop,
            Index = indexProp,
            NameOffset = nameoffsetProp,
            Offset = offsetProp,
            Path = pathProp,
            Size = sizeProp
        };
    }

    public override void Write(Utf8JsonWriter writer, TES3File value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        writer.WriteString("$type", "TES3File");
        writer.WritePropertyName("Hash1");
        JsonSerializer.Serialize(writer, value.Hash1, options);
        writer.WritePropertyName("Hash2");
        JsonSerializer.Serialize(writer, value.Hash2, options);
        writer.WritePropertyName("Index");
        JsonSerializer.Serialize(writer, value.Index, options);
        writer.WritePropertyName("NameOffset");
        JsonSerializer.Serialize(writer, value.NameOffset, options);
        writer.WritePropertyName("Offset");
        JsonSerializer.Serialize(writer, value.Offset, options);
        writer.WritePropertyName("Path");
        JsonSerializer.Serialize(writer, value.Path, options);
        writer.WritePropertyName("Size");
        JsonSerializer.Serialize(writer, value.Size, options);
        writer.WriteEndObject();
    }
}